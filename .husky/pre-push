#!/usr/bin/env bash
set -euo pipefail

# ensure we run at repo root
toplevel=$(git rev-parse --show-toplevel)
cd "$toplevel"

echo "ðŸ” verifying submodules (read-only)â€¦"

# 0) fail fast if any submodule is uninitialized
if git submodule status --recursive | grep -q '^-'; then
  echo "âŒ Uninitialized submodules detected."
  echo "   Run once (outside the hook): git submodule update --init --recursive"
  exit 1
fi

# 1) iterate each submodule to check cleanliness + ahead/behind
git submodule foreach --recursive '
  set -e
  echo ""
  echo "â€” $name â€”"

  # uncommitted/staged changes guard
  if ! git diff --quiet || ! git diff --cached --quiet; then
    echo "âŒ $name has uncommitted or staged changes. Commit or stash before pushing the superproject."
    exit 1
  fi

  upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
  if [ -z "$upstream" ]; then
    echo "â„¹ï¸  $name has no upstream set (no tracking branch). Skipping ahead/behind checks."
    exit 0
  fi

  # read-only network update of refs (does not touch config like core.worktree)
  git fetch --quiet --prune

  counts=$(git rev-list --left-right --count "$upstream"...HEAD 2>/dev/null || echo "0 0")
  # Split robustly on any whitespace (tabs/spaces/newlines)
  read -r behind ahead <<<"$counts"
  # Fallbacks if parsing fails
  [[ "$behind" =~ ^[0-9]+$ ]] || behind=0
  [[ "$ahead"  =~ ^[0-9]+$ ]] || ahead=0

  if [ "$behind" != "0" ]; then
    echo "âŒ $name is BEHIND $upstream by $behind commit(s). Pull/rebase the submodule first."
    exit 1
  fi

  if [ "$ahead" != "0" ]; then
    echo "âŒ $name is AHEAD of $upstream by $ahead commit(s). Push the submodule first."
    exit 1
  fi

  echo "âœ… $name is clean and in sync with $upstream."
'

echo ""
echo "âœ… all submodules clean & synced. proceeding with superproject pushâ€¦"
